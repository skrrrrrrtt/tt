--!strict
-- Kohana Volcano + LegitFishing + GPT Hub (Auto-detect Rod/Bait Farming Status)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Player = Players.LocalPlayer
local Character, Humanoid

----------------------------------------------------------------
-- 0. Prices (exact names must match tools/inventory)
----------------------------------------------------------------
local RodPrices = {
    ["Starter Rod (50$)"]     = 50,
    ["Luck Rod (350$)"]       = 350,
    ["Carbon Rod (900$)"]     = 900,
    ["Grass Rod (1500$)"]     = 1500,
    ["Desmascus Rod (3000$)"] = 3000,
    ["Ice Rod (5000$)"]       = 5000,
    ["Lucky Rod (15000$)"]    = 15000,
    ["Midnight Rod (50000$)"] = 50000,
    ["SteamPunk Rod (215000$"]= 215000,
    ["Chrome Rod (437000$)"]  = 437000,
    ["Fluorescent Rod (715000$)"] = 715000,
    ["Astral Rod (1M$)"]      = 1000000,
    ["Ares Rod (3M$)"]        = 3000000,
    ["Angler Rod (8M$)"]      = 8000000,
    ["Bambo Rod (12M$)"]      = 12000000,
}

local BaitPrices = {
    ["TopWater Bait (100$)"]  = 100,
    ["Luck Bait (1000$)"]     = 1000,
    ["Midnight Bait (3000$)"] = 3000,
    ["Nature Bait (83500$)"]  = 83500,
    ["Chroma Bait (290000$)"] = 290000,
    ["Dark Matter Bait (630000$)"] = 630000,
    ["Corrupt Bait (1.15M$)"] = 1150000,
    ["Aether Bait (3.70M$)"]  = 3700000,
    ["Floral Bait (4M$)"]     = 4000000,
}

-- Build sorted lists (ascending)
local function makeSortedList(priceMap)
    local list = {}
    for name, price in pairs(priceMap) do table.insert(list, {name = name, price = price}) end
    table.sort(list, function(a,b) return a.price < b.price end)
    return list
end

local RodList = makeSortedList(RodPrices)
local BaitList = makeSortedList(BaitPrices)

----------------------------------------------------------------
-- 1. Wait for character + teleport
----------------------------------------------------------------
local function waitForCharacter()
    if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
        Character = Player.Character
        Humanoid = Character:FindFirstChildOfClass("Humanoid")
        return
    end
    Player.CharacterAdded:Wait()
    Character = Player.Character
    Humanoid = Character:WaitForChild("Humanoid")
end
waitForCharacter()

local volcanoCFrame = CFrame.new(
    -628.758911, 35.710186, 104.373764,
    0.482912123, 1.81591773e-08, 0.875668824,
    3.01732896e-08, 1, -3.73774007e-08,
    -0.875668824, 4.44718076e-08, 0.482912123
)
Character:WaitForChild("HumanoidRootPart").CFrame = volcanoCFrame

----------------------------------------------------------------
-- 2. Equip rod from hotbar (safe)
----------------------------------------------------------------
task.delay(0.5, function()
    local Net
    pcall(function()
        Net = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
    end)
    if Net then
        local REEquipToolFromHotbar = Net:FindFirstChild("RE/EquipToolFromHotbar")
        if REEquipToolFromHotbar then
            pcall(function() REEquipToolFromHotbar:FireServer(1) end)
        end
    end
end)

----------------------------------------------------------------
-- 3. LegitFishing automation (unchanged)
----------------------------------------------------------------
task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    local Net
    pcall(function()
        Net = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
    end)
    if not Net then return end

    local RfCancel = Net:WaitForChild("RF/CancelFishingInputs")
    local FishingController = require(ReplicatedStorage.Controllers.FishingController)
    local Constants = require(ReplicatedStorage.Shared.Constants)

    -- Instant recast
    Constants.FishingCooldownTime = 0

    local States = {
        Idle      = "Idle",
        Casting   = "Casting",
        Waiting   = "Waiting",
        Minigame  = "Minigame",
        Reeling   = "Reeling",
        Completed = "Completed",
    }

    local CurrentState = States.Idle
    local CurrentGuid  = nil
    local MinigameCompleted = false
    local StateChangeTime = os.clock()

    -- Robust fishing objects finder (used in state detection)
    local function getFishingObjects()
        local objs = { bobber = nil, line = nil }
        local ok, fc = pcall(function() return require(ReplicatedStorage.Controllers.FishingController) end)
        if ok and fc then
            if fc.FishingBobber and fc.FishingBobber.Parent then objs.bobber = fc.FishingBobber end
            if fc.FishingLine and fc.FishingLine.Parent then objs.line = fc.FishingLine end
        end

        -- search common workspace containers
        if not objs.bobber then
            local namesToTry = {"Bobbers", "Fishing", "Props", "FishingBobbers"}
            for _, nm in ipairs(namesToTry) do
                local container = workspace:FindFirstChild(nm)
                if container then
                    for _, kid in ipairs(container:GetDescendants()) do
                        if kid:IsA("BasePart") and (kid.Name:lower():find("bobber") or kid.Name:lower():find("float")) then
                            objs.bobber = kid
                            break
                        end
                    end
                end
                if objs.bobber then break end
            end
        end

        -- check player's character for bobber parts/tools
        if not objs.bobber and Player.Character then
            for _, v in ipairs(Player.Character:GetDescendants()) do
                if v:IsA("BasePart") and (v.Name:lower():find("bobber") or v.Name:lower():find("float") or v.Name:lower():find("bob")) then
                    objs.bobber = v
                    break
                end
                if v:IsA("Tool") and v.Name:lower():find("bobber") then
                    objs.bobber = v
                    break
                end
            end
        end

        -- fishing line search
        if not objs.line then
            for _, nm in ipairs({"FishingLines","Lines","Ropes"}) do
                local container = workspace:FindFirstChild(nm)
                if container then
                    for _, kid in ipairs(container:GetDescendants()) do
                        if kid:IsA("BasePart") and kid.Name:lower():find("line") then
                            objs.line = kid
                            break
                        end
                    end
                end
                if objs.line then break end
            end
        end

        if not objs.line then
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and (obj.Name:lower():find("line") or obj.Name:lower():find("string")) then
                    objs.line = obj
                    break
                end
            end
        end

        return objs
    end

    local function DetectState()
        local Guid = FishingController:GetCurrentGUID()
        if Guid then
            if CurrentState ~= States.Minigame then
                CurrentGuid = Guid
                MinigameCompleted = false
            end
            return States.Minigame
        end

        if CurrentGuid and not Guid then
            local fishingObjs = getFishingObjects()
            local IsBusy = (FishingController.FishingLine and FishingController.FishingLine.Parent)
                or (FishingController.FishingBobber and FishingController.FishingBobber.Parent)
                or (fishingObjs.line and fishingObjs.line.Parent)
                or (fishingObjs.bobber and fishingObjs.bobber.Parent)
                or FishingController._isFishing
                or FishingController._isReeling

            if IsBusy then
                return States.Reeling
            else
                if MinigameCompleted then
                    return States.Completed
                else
                    CurrentGuid = nil
                    return States.Idle
                end
            end
        end

        return (FishingController.OnCooldown and FishingController:OnCooldown() or false)
            and States.Waiting or States.Idle
    end

    while true do
        if not (Character and Character:FindFirstChild("HumanoidRootPart")) then
            task.wait(1)
            continue
        end

        local NewState = DetectState()
        if NewState ~= CurrentState then
            CurrentState = NewState
            StateChangeTime = os.clock()
        end

        -- Timeout stuck casting/waiting
        if (CurrentState == States.Casting or CurrentState == States.Waiting)
            and (os.clock() - StateChangeTime) > 8 then
            pcall(RfCancel.InvokeServer, RfCancel)
            CurrentState = States.Idle
            StateChangeTime = os.clock()
        end

        -- Idle → Cast
        if CurrentState == States.Idle then
            if not FishingController:OnCooldown() then
                pcall(RfCancel.InvokeServer, RfCancel)
                pcall(FishingController.RequestChargeFishingRod, FishingController, nil, true)
                CurrentState = States.Casting
            end
        end

        -- Minigame → Spam clicks
        if CurrentState == States.Minigame then
            local ClickConnection
            local ClickCount = 0
            ClickConnection = RunService.Heartbeat:Connect(function()
                if not FishingController:GetCurrentGUID() then
                    if ClickConnection then ClickConnection:Disconnect() end
                    return
                end
                for i = 1, 5 do
                    pcall(FishingController.FishingMinigameClick, FishingController)
                end
                ClickCount += 5
            end)

            while FishingController:GetCurrentGUID() do task.wait() end
            if ClickConnection then ClickConnection:Disconnect() end

            MinigameCompleted = true
            CurrentState = States.Completed
        end

        -- Completed → Reset
        if CurrentState == States.Completed then
            CurrentGuid = nil
            MinigameCompleted = false
            CurrentState = States.Idle
        end

        task.wait()
    end
end)

----------------------------------------------------------------
-- 4. UI: GPT Hub + compact farming status line
----------------------------------------------------------------
local PlayerGui = Player:WaitForChild("PlayerGui")
local Gui = Instance.new("ScreenGui")
Gui.Name = "GPTHub"
Gui.ResetOnSpawn = false
Gui.Parent = PlayerGui

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 360, 0, 140)
Frame.Position = UDim2.new(0.02, 0, 0.22, 0)
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BackgroundTransparency = 0.35
Frame.BorderSizePixel = 0
Frame.Parent = Gui

local function makeLabel(text, posY, fontSize, bold)
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, -14, 0, 20)
    lbl.Position = UDim2.new(0, 7, 0, posY)
    lbl.BackgroundTransparency = 1
    lbl.Font = (bold and Enum.Font.GothamBold) or Enum.Font.Gotham
    lbl.TextSize = fontSize or 16
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.TextColor3 = Color3.fromRGB(255,255,255)
    lbl.Text = text
    lbl.Parent = Frame
    return lbl
end

local Title = makeLabel("GPT Hub", 6, 18, true)
local StatusLabel = makeLabel("Status: Running", 30, 14, false)
local FarmingStatusLabel = makeLabel("Farming for: - | 0/0 coins | fish: 0", 54, 14, false)
local UptimeLabel = makeLabel("Uptime: 00:00:00", 78, 14, false)
local FishLabel = makeLabel("Session Fish: 0", 102, 14, false)

----------------------------------------------------------------
-- 5. Utilities: number formatting + ownership detection (REPLACED)
----------------------------------------------------------------
local function formatNum(n)
    if not n then return "0" end
    local s = tostring(math.floor(n))
    local b = s:reverse():gsub("(%d%d%d)","%1,"):reverse()
    if b:sub(1,1) == "," then b = b:sub(2) end
    return b
end

-- safe Replion Data client
local Data = nil
local success, Replion = pcall(function() return require(ReplicatedStorage.Packages.Replion).Client end)
if success and Replion then
    pcall(function() Data = Replion:WaitReplion("Data") end)
end

-- >>> REPLACEMENT: robust ownership + fishing object detection
local function normalizeName(n)
    if not n then return "" end
    local s = tostring(n)
    -- remove leading exclamation markers, prices in parentheses, dollar signs
    s = s:gsub("^%s*!!!%s*", "")
    s = s:gsub("%s*%b()", "")
    s = s:gsub("%$", "")
    s = s:lower():gsub("%s+", " "):gsub("^%s+",""):gsub("%s+$","")
    return s
end

local function nameMatches(actualName, expectedName)
    actualName = normalizeName(actualName)
    expectedName = normalizeName(expectedName)
    if expectedName == "" then return false end
    if actualName:find(expectedName, 1, true) then return true end
    local token = expectedName:match("(%w+)")
    if token and actualName:find(token, 1, true) then return true end
    return false
end

local function containerHasItem(container, expectedName)
    if not container then return false end
    for _, v in ipairs(container:GetChildren()) do
        if v:IsA("Tool") or v:IsA("Accessory") or v:IsA("Model") or v:IsA("BasePart") then
            if nameMatches(v.Name, expectedName) then
                return true
            end
            local display = v:FindFirstChild("DisplayName") or v:FindFirstChild("Name")
            if display and display.Value and nameMatches(display.Value, expectedName) then
                return true
            end
        end
    end
    return false
end

local function ownsInDataFlexible(expectedName)
    if not Data then return false end
    local ok, inv = pcall(function() return Data:Get({"Inventory"}) end)
    if not ok or not inv then
        ok, inv = pcall(function() return Data:Get({"Inventory","Items"}) end)
        if not ok or not inv then return false end
    end
    local function searchTable(tbl)
        for _, v in pairs(tbl) do
            if type(v) == "table" then
                local nm = v.Name or v.DisplayName or v.ItemName or v.Item or v.ItemId
                if nm and nameMatches(nm, expectedName) then return true end
                if searchTable(v) then return true end
            else
                if tostring(v) and nameMatches(tostring(v), expectedName) then return true end
            end
        end
        return false
    end
    return searchTable(inv)
end

local function ownsItemFlexible(expectedName)
    if not expectedName or expectedName == "" then return false end
    if Player.Character and containerHasItem(Player.Character, expectedName) then return true end
    local bp = Player:FindFirstChild("Backpack")
    if bp and containerHasItem(bp, expectedName) then return true end
    if ownsInDataFlexible(expectedName) then return true end
    return false
end

local function ownsBetterOrEqualBait(minPrice)
    for _, entry in ipairs(BaitList) do
        if entry.price >= minPrice then
            if ownsItemFlexible(entry.name) then
                return true, entry.name, entry.price
            end
        end
    end
    return false, nil, nil
end
-- <<< END REPLACEMENT

----------------------------------------------------------------
-- 6. Coins detection: Replion Data preferred, else leaderstats fallback
----------------------------------------------------------------
local currentCoins = 0

if Data then
    pcall(function()
        Data:OnChange({"Currency","Coins"}, function(coins)
            currentCoins = tonumber(coins) or 0
        end)
        local ok, initCoins = pcall(function() return Data:Get({"Currency","Coins"}) end)
        if ok and type(initCoins) == "number" then currentCoins = initCoins end
    end)
else
    -- fallback
    local ls = Player:FindFirstChild("leaderstats")
    if ls and ls:FindFirstChild("Coins") then
        local coinsObj = ls.Coins
        currentCoins = coinsObj.Value
        coinsObj:GetPropertyChangedSignal("Value"):Connect(function() currentCoins = coinsObj.Value end)
    end
end

----------------------------------------------------------------
-- 7. Fish counting (session)
----------------------------------------------------------------
local sessionFish = 0
local totalFish = 0

local okNet, Net = pcall(function()
    return ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
end)

local FishNotify = nil
if okNet and Net then FishNotify = Net:FindFirstChild("RE/ObtainedNewFishNotification") end

if FishNotify then
    FishNotify.OnClientEvent:Connect(function(...)
        sessionFish += 1
        totalFish += 1
        FishLabel.Text = "Session Fish: " .. tostring(sessionFish)
    end)
end

----------------------------------------------------------------
-- 8. AUTO-DETECT NEXT TARGETS & Update UI loop
----------------------------------------------------------------
-- helper: find highest owned index in sorted price list (uses flexible owner check)
local function highestOwnedIndex(list)
    local idx = 0
    for i = 1, #list do
        if ownsItemFlexible(list[i].name) then
            idx = i
        end
    end
    return idx -- 0 means none owned
end

-- main updater
task.spawn(function()
    local startTime = os.clock()
    while true do
        -- uptime
        local elapsed = os.clock() - startTime
        local h = math.floor(elapsed / 3600)
        local m = math.floor((elapsed % 3600) / 60)
        local s = math.floor(elapsed % 60)
        UptimeLabel.Text = string.format("Uptime: %02d:%02d:%02d", h, m, s)

        -- find rod target (next after highest owned)
        local rodOwnedIdx = highestOwnedIndex(RodList)
        local rodTargetIdx = math.min(#RodList, rodOwnedIdx + 1) -- if owns highest, target will be highest (owned)
        local rodTarget = RodList[rodTargetIdx]
        local ownsTargetRod = ownsItemFlexible(rodTarget and rodTarget.name)

        -- find bait target, but only consider after rod is owned
        local baitOwnedIdx = highestOwnedIndex(BaitList)
        local baitTargetIdx = math.min(#BaitList, baitOwnedIdx + 1)
        local baitTarget = BaitList[baitTargetIdx]
        local ownsTargetBait = baitTarget and ownsItemFlexible(baitTarget.name)

        -- If player already owns a bait more expensive than the baitTarget, skip cheaper farming
        local ownsBetter, betterName, betterPrice = false, nil, nil
        if baitTarget then ownsBetter, betterName, betterPrice = ownsBetterOrEqualBait(baitTarget.price) end

        -- Compose status string and priority:
        -- Priority: rod. If rod is not yet owned (i.e. rodOwnedIdx < #RodList), show rod progress.
        local statusText = ""
        if rodOwnedIdx < #RodList and not ownsItemFlexible(RodList[rodOwnedIdx + 1].name) then
            -- still farming rod
            local targetName = RodList[rodOwnedIdx + 1].name
            local targetPrice = RodList[rodOwnedIdx + 1].price
            statusText = ("Farming for: %s | %s / %s coins | fish: %d"):format(
                targetName,
                formatNum(currentCoins),
                formatNum(targetPrice),
                sessionFish
            )
        else
            -- rod done or at top; move to bait
            if baitTarget == nil then
                statusText = ("Farming for: Bait (none) | %s / %s coins | fish: %d"):format(formatNum(currentCoins), "0", sessionFish)
            else
                -- if owns better bait => show skip
                if ownsBetter and betterPrice and betterPrice >= baitTarget.price then
                    statusText = ("Farming for: %s (skip — own %s) | %s / %s coins | fish: %d"):format(
                        baitTarget.name, betterName or "better bait", formatNum(currentCoins), formatNum(baitTarget.price), sessionFish
                    )
                else
                    statusText = ("Farming for: %s | %s / %s coins | fish: %d"):format(
                        baitTarget.name, formatNum(currentCoins), formatNum(baitTarget.price), sessionFish
                    )
                end
            end
        end

        FarmingStatusLabel.Text = statusText

        -- small extra: update status label
        StatusLabel.Text = "Status: Auto-Farming (Rod priority)"
        -- fish label already updated by event

        task.wait(0.5)
    end
end)

print("Auto-detect farming system loaded.")
